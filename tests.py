from datetime import datetime

import pandas as pd
# Generated by CodiumAI

# Dependencies:
# pip install pytest-mock
import pytest

from actors import StockDataActor
from backtest_v1 import BuySellStrategy, bt
from models import StockData
from rules import Rule, apply_rules, Position


class TestStockDataActor:
    #  Tests that the class is successfully initialized with valid parameters. Tags: [happy path]
    def test_init_valid_parameters(self):
        api = tradeapi.REST('key_id', 'secret_key', base_url='https://paper-api.alpaca.markets')
        symbol = 'AAPL'
        timeframe = '1D'
        actor = StockDataActor(api, symbol, timeframe)
        assert actor.api == api
        assert actor.symbol == symbol
        assert actor.timeframe == timeframe
        assert actor.current_data is None

    #  Tests that the get_data() method successfully retrieves and returns valid data. Tags: [happy path]
    def test_get_data_valid(self, mocker):
        api = tradeapi.REST('key_id', 'secret_key', base_url='https://paper-api.alpaca.markets')
        symbol = 'AAPL'
        timeframe = '1D'
        actor = StockDataActor(api, symbol, timeframe)
        mocker.patch.object(api, 'get_barset', return_value={symbol: [mocker.Mock(_raw={'open': 100, 'high': 110, 'low': 90, 'close': 105, 'volume': 1000000})]})
        data = actor.get_data()
        assert isinstance(data, pd.DataFrame)
        assert len(data) == 1
        assert data.iloc[0]['open'] == 100
        assert data.iloc[0]['high'] == 110
        assert data.iloc[0]['low'] == 90
        assert data.iloc[0]['close'] == 105
        assert data.iloc[0]['volume'] == 1000000

    #  Tests that the get_data() method gracefully handles being called before any data has been retrieved. Tags: [edge case]
    def test_get_data_no_data(self, mocker):
        api = tradeapi.REST('key_id', 'secret_key', base_url='https://paper-api.alpaca.markets')
        symbol = 'AAPL'
        timeframe = '1D'
        actor = StockDataActor(api, symbol, timeframe)
        data = actor.get_data()
        assert data is None

    #  Tests that the get_data() method gracefully handles being called with invalid symbol or timeframe parameters. Tags: [edge case]
    def test_get_data_invalid_params(self, mocker):
        api = tradeapi.REST('key_id', 'secret_key', base_url='https://paper-api.alpaca.markets')
        symbol = 'INVALID'
        timeframe = 'INVALID'
        actor = StockDataActor(api, symbol, timeframe)
        mocker.patch.object(api, 'get_barset', side_effect=tradeapi.rest.APIError('Invalid symbol or timeframe'))
        with pytest.raises(tradeapi.rest.APIError):
            actor.get_data()

    #  Tests that the get_data() method gracefully handles being called with a limit parameter that exceeds the maximum allowed by the API. Tags: [edge case]
    def test_get_data_limit_exceeded(self, mocker):
        api = tradeapi.REST('key_id', 'secret_key', base_url='https://paper-api.alpaca.markets')
        symbol = 'AAPL'
        timeframe = '1D'
        actor = StockDataActor(api, symbol, timeframe)
        mocker.patch.object(api, 'get_barset', side_effect=tradeapi.rest.APIError('Maximum limit exceeded'))
        with pytest.raises(tradeapi.rest.APIError):
            actor.get_data(limit=1000)

    #  Tests that the get_data() method successfully updates the current data with each call. Tags: [happy path]
    def test_get_data_updated(self, mocker):
        api = tradeapi.REST('key_id', 'secret_key', base_url='https://paper-api.alpaca.markets')
        symbol = 'AAPL'
        timeframe = '1D'
        actor = StockDataActor(api, symbol, timeframe)
        mocker.patch.object(api, 'get_barset', return_value={symbol: [mocker.Mock(_raw={'open': 100, 'high': 110, 'low': 90, 'close': 105, 'volume': 1000000})]})
        data1 = actor.get_data()
        mocker.patch.object(api, 'get_barset', return_value={symbol: [mocker.Mock(_raw={'open': 110, 'high': 120, 'low': 95, 'close': 115, 'volume': 2000000})]})
        data2 = actor.get_data()
        assert len(data1) == 1
        assert len(data2) == 2
        assert data2.iloc[0]['open'] == 100
        assert data2.iloc[0]['high'] == 110
        assert data2.iloc[0]['low'] == 90
        assert data2.iloc[0]['close'] == 105
        assert data2.iloc[0]['volume'] == 1000000
        assert data2.iloc[1]['open'] == 110
        assert data2.iloc[1]['high'] == 120
        assert data2.iloc[1]['low'] == 95
        assert data2.iloc[1]['close'] == 115
        assert data2.iloc[1]['volume'] == 2000000



# Generated by CodiumAI

import pytest

"""
Code Analysis

Main functionalities:
The BuySellStrategy class is a backtesting strategy that implements a set of trading rules for buying and selling assets based on moving averages and candlestick patterns. The strategy places buy and sell orders based on the current market conditions and the parameters set in the trading_rules dictionary. It also includes methods for submitting and closing orders, as well as logging and plotting the results of the backtest.

Methods:
- __init__: initializes the strategy and sets initial values for the fields
- next: called on every new candle, implements the trading rules and places orders accordingly
- submit_sell_order: submits a sell order with a stop loss and take profit price
- close_sell_order: closes the current sell order
- notify_order: notifies when an order is submitted, accepted, or rejected
- notify_trade: notifies when a trade has been completed
- stop: called when the strategy is closed, logs and plots the results of the backtest
- plot_results: plots the equity curve, buy and hold equity curve, and strategy vs buy and hold equity curve
- log: logging function for the strategy
- get_analysis: returns the buy and hold returns and strategy vs buy and hold returns
- get_analysis_df: returns the buy and hold returns and strategy vs buy and hold returns as a dataframe
- get_analysis_df_with_parameters: returns the buy and hold returns and strategy vs buy and hold returns as a dataframe with the strategy parameters
- get_parameters: returns the strategy parameters
- get_parameters_df: returns the strategy parameters as a dataframe

Fields:
- params: a SimpleNamespace object that contains the trading rules and other parameters for the strategy
- sell_order: the current sell order
- buy_signal_triggered: a boolean that indicates whether a buy signal has been triggered
- buy_order_placed: a boolean that indicates whether a buy order has been placed
- sell_order_placed: a boolean that indicates whether a sell order has been placed
- buy_limit_price: the limit price for the current buy order
- stop_loss_price: the stop loss price for the current buy order
- take_profit_price: the take profit price for the current buy order
"""

class TestBuySellStrategy:
    #  Tests that the strategy is closed successfully, final portfolio value, returns, and buy and hold returns are calculated and printed. Tags: [happy path]
    def test_strategy_close(self):
        """
        Tests that the strategy is closed successfully, final portfolio value, returns, and buy and hold returns are calculated and printed.
        """
        strategy = BuySellStrategy()
        strategy.initial_portfolio_value = 10000
        strategy.broker.set_value(strategy.initial_portfolio_value)
        strategy.equity_curve = [10000, 11000, 12000, 13000]
        strategy.buy_and_hold_equity_curve = [10000, 10500, 11000, 11500]
        strategy.final_portfolio_value = None
        strategy.returns = None
        strategy.buy_and_hold_returns = None
        strategy.strategy_vs_buy_and_hold_returns = None

        strategy.stop()

        assert strategy.final_portfolio_value == 13000
        assert strategy.returns == 3000
        assert strategy.buy_and_hold_returns == 1500
        assert strategy.strategy_vs_buy_and_hold_returns == 1500

    #  Tests that a buy signal is triggered and a buy order is placed successfully. Tags: [happy path]
    def test_buy_signal_triggered(self):
        """
        Tests that a buy signal is triggered and a buy order is placed successfully.
        """
        data = bt.feeds.PandasData(dataname=pd.DataFrame({
            'open': [10, 11, 12],
            'high': [11, 12, 13],
            'low': [9, 10, 11],
            'close': [11, 12, 13],
            'volume': [100, 200, 300],
            'datetime': [datetime(2022, 1, 1, 0, 0), datetime(2022, 1, 1, 0, 1), datetime(2022, 1, 1, 0, 2)]
        }))
        strategy = BuySellStrategy()
        cerebro = bt.Cerebro()
        cerebro.adddata(data)
        cerebro.addstrategy(strategy)
        cerebro.broker.set_cash(10000)
        cerebro.broker.setcommission(commission=0.001)
        cerebro.run()

        assert strategy.buy_order_placed == True

    #  Tests that no buy signal is triggered. Tags: [edge case]
    def test_no_buy_signal(self):
        """
        Tests that no buy signal is triggered.
        """
        data = bt.feeds.PandasData(dataname=pd.DataFrame({
            'open': [10, 11, 12],
            'high': [11, 12, 13],
            'low': [9, 10, 11],
            'close': [9, 10, 11],
            'volume': [100, 200, 300],
            'datetime': [datetime(2022, 1, 1, 0, 0), datetime(2022, 1, 1, 0, 1), datetime(2022, 1, 1, 0, 2)]
        }))
        strategy = BuySellStrategy()
        cerebro = bt.Cerebro()
        cerebro.adddata(data)
        cerebro.addstrategy(strategy)
        cerebro.broker.set_cash(10000)
        cerebro.broker.setcommission(commission=0.001)
        cerebro.run()

        assert strategy.buy_order_placed == False

    #  Tests that no sell order is submitted. Tags: [edge case]
    def test_no_sell_order(self):
        """
        Tests that no sell order is submitted.
        """
        data = bt.feeds.PandasData(dataname=pd.DataFrame({
            'open': [10, 11, 12],
            'high': [11, 12, 13],
            'low': [9, 10, 11],
            'close': [11, 12, 13],
            'volume': [100, 200, 300],
            'datetime': [datetime(2022, 1, 1, 0, 0), datetime(2022, 1, 1, 0, 1), datetime(2022, 1, 1, 0, 2)]
        }))
        strategy = BuySellStrategy()
        cerebro = bt.Cerebro()
        cerebro.adddata(data)
        cerebro.addstrategy(strategy)
        cerebro.broker.set_cash(10000)
        cerebro.broker.setcommission(commission=0.001)
        cerebro.run()

        assert strategy.sell_order is None

    #  Tests that a sell order is submitted, filled, and closed successfully. Tags: [happy path]
    def test_sell_order(self):
        """
        Tests that a sell order is submitted, filled, and closed successfully.
        """
        data = bt.feeds.PandasData(dataname=pd.DataFrame({
            'open': [10, 11, 12],
            'high': [11, 12, 13],
            'low': [9, 10, 11],
            'close': [13, 12, 11],
            'volume': [100, 200, 300],
            'datetime': [datetime(2022, 1, 1, 0, 0), datetime(2022, 1, 1, 0, 1), datetime(2022, 1, 1, 0, 2)]
        }))
        strategy = BuySellStrategy()
        cerebro = bt.Cerebro()
        cerebro.adddata(data)
        cerebro.addstrategy(strategy)
        cerebro.broker.set_cash(10000)
        cerebro.broker.setcommission(commission=0.001)
        cerebro.run()

        assert strategy.sell_order is None

    #  Tests that an invalid sell order status is handled correctly. Tags: [edge case]
    def test_invalid_sell_order_status(self):
        """
        Tests that an invalid sell order status is handled correctly.
        """
        data = bt.feeds.PandasData(dataname=pd.DataFrame({
            'open': [10, 11, 12],
            'high': [11, 12, 13],
            'low': [9, 10, 11],
            'close': [13, 12, 11],
            'volume': [100, 200, 300],
            'datetime': [datetime(2022, 1, 1, 0, 0), datetime(2022, 1, 1, 0, 1), datetime(2022, 1, 1, 0, 2)]
        }))
        strategy = BuySellStrategy()
        cerebro = bt.Cerebro()
        cerebro.adddata(data)
        cerebro.addstrategy(strategy)
        cerebro.broker.set_cash(10000)
        cerebro.broker.setcommission(commission=0.001)
        strategy.sell_order = bt.Order()
        strategy.sell_order.status = "invalid"
        strategy.close_sell_order()

        assert strategy.sell_order is None


# Generated by CodiumAI

# Dependencies:
# pip install pytest-mock
import pytest

"""
Code Analysis

Objective:
- The objective of the apply_rules function is to apply entry, exit, and reverse rules to a list of stock data and positions, and execute corresponding actions based on the triggered rules.

Inputs:
- entry_rules: a list of Rule objects representing the entry rules
- exit_rules: a list of Rule objects representing the exit rules
- reverse_rules: a list of Rule objects representing the reverse rules
- stock_data: a list of StockData objects representing the historical stock data
- positions: a list of Position objects representing the current positions

Flow:
- Define conditions for the rules engine based on the stock data and positions
- Create a RuleEngine object
- Add entry, exit, and reverse rules to the RuleEngine object
- Loop through the stock data and apply the rules to each data point
- If an entry rule is triggered, calculate the quantity of shares to buy, place a buy order, create a new Position object, and append it to the positions list
- If an exit rule is triggered for a position, place a sell order, create a new Trade object, and remove the position from the positions list
- If a reverse rule is triggered for a position, close the current position, calculate the quantity of shares to buy, place a buy order, create a new Position object, and append it to the positions list
- Return a tuple of the trades and positions lists

Outputs:
- trades: a list of Trade objects representing the executed trades
- positions: a list of Position objects representing the current positions

Additional aspects:
- The apply_rules function uses other helper functions such as calculate_quantity, place_buy_order, close_position, and close_and_reverse to execute the corresponding actions for the triggered rules.
- The apply_rules function also uses the Rule and StockData classes to represent the rules and stock data, respectively.
- The apply_rules function is designed to be used in a larger trading algorithm that utilizes a rules engine to make trading decisions.
"""

class TestApplyRules:
    #  Tests that the function handles invalid input types and values. Tags: [edge case]
    def test_apply_rules_invalid_input(self, mocker):
        # Test that the function handles invalid input types and values
        entry_rules = 'invalid'
        exit_rules = ['invalid']
        reverse_rules = {'invalid': 'invalid'}
        stock_data = 'invalid'
        positions = ['invalid']

        with pytest.raises(TypeError):
            apply_rules(entry_rules, exit_rules, reverse_rules, stock_data, positions)

        entry_rules = [Rule(name='rule1', condition='condition1', actions=['action1'])]
        exit_rules = [Rule(name='rule2', condition='condition2', actions=['action2'])]
        reverse_rules = [Rule(name='rule3', condition='condition3', actions=['action3'])]
        stock_data = [StockData(symbol='AAPL', date='2022-01-01', open=100, high=110, low=90, close=105, volume=1000, vwap=100, adj_close=100)]
        positions = [Position(symbol='AAPL', qty=10, avg_price=100, side='long', time='2022-01-01')]

        api_mock = mocker.Mock()
        api_mock.get_account.return_value = {'buying_power': '1000'}

        with pytest.raises(TypeError):
            apply_rules(entry_rules, exit_rules, reverse_rules, stock_data, 'invalid')

        with pytest.raises(TypeError):
            apply_rules(entry_rules, exit_rules, reverse_rules, 'invalid', positions)

        with pytest.raises(TypeError):
            apply_rules(entry_rules, exit_rules, 'invalid', stock_data, positions)

        with pytest.raises(TypeError):
            apply_rules(entry_rules, 'invalid', reverse_rules, stock_data, positions)

        with pytest.raises(TypeError):
            apply_rules('invalid', exit_rules, reverse_rules, stock_data, positions)

        with pytest.raises(ValueError):
            apply_rules([], exit_rules, reverse_rules, stock_data, positions)

        with pytest.raises(ValueError):
            apply_rules(entry_rules, [], reverse_rules, stock_data, positions)

        with pytest.raises(ValueError):
            apply_rules(entry_rules, exit_rules, [], stock_data, positions)

        with pytest.raises(ValueError):
            apply_rules(entry_rules, exit_rules, reverse_rules, [], positions)

        with pytest.raises(ValueError):
            apply_rules(entry_rules, exit_rules, reverse_rules, stock_data, [])

    #  Tests that the function handles empty entry rules lists. Tags: [edge case]
    def test_apply_rules_entry_rules_empty(self, mocker):
        # Test that the function handles empty entry rules lists
        entry_rules = []
        exit_rules = [Rule(name='rule2', condition='condition2', actions=['action2'])]
        reverse_rules = [Rule(name='rule3', condition='condition3', actions=['action3'])]
        stock_data = [StockData(symbol='AAPL', date='2022-01-01', open=100, high=110, low=90, close=105, volume=1000, vwap=100, adj_close=100)]
        positions = [Position(symbol='AAPL', qty=10, avg_price=100, side='long', time='2022-01-01')]

        api_mock = mocker.Mock()
        api_mock.get_account.return_value = {'buying_power': '1000'}

        trades, new_positions = apply_rules(entry_rules, exit_rules, reverse_rules, stock_data, positions)

        assert trades == []
        assert new_positions == positions

    #  Tests that the function handles empty exit rules lists. Tags: [edge case]
    def test_apply_rules_exit_rules_empty(self, mocker):
        # Test that the function handles empty exit rules lists
        entry_rules = [Rule(name='rule1', condition='condition1', actions=['action1'])]
        exit_rules = []
        reverse_rules = [Rule(name='rule3', condition='condition3', actions=['action3'])]
        stock_data = [StockData(symbol='AAPL', date='2022-01-01', open=100, high=110, low=90, close=105, volume=1000, vwap=100, adj_close=100)]
        positions = [Position(symbol='AAPL', qty=10, avg_price=100, side='long', time='2022-01-01')]

        api_mock = mocker.Mock()
        api_mock.get_account.return_value = {'buying_power': '1000'}

        trades, new_positions = apply_rules(entry_rules, exit_rules, reverse_rules, stock_data, positions)

        assert trades == []
        assert new_positions == positions

    #  Tests that the function handles empty reverse rules lists. Tags: [edge case]
    def test_apply_rules_reverse_rules_empty(self, mocker):
        # Test that the function handles empty reverse rules lists
        entry_rules = [Rule(name='rule1', condition='condition1', actions=['action1'])]
        exit_rules = [Rule(name='rule2', condition='condition2', actions=['action2'])]
        reverse_rules = []
        stock_data = [StockData(symbol='AAPL', date='2022-01-01', open=100, high=110, low=90, close=105, volume=1000, vwap=100, adj_close=100)]
        positions = [Position(symbol='AAPL', qty=10, avg_price=100, side='long', time='2022-01-01')]

        api_mock = mocker.Mock()
        api_mock.get_account.return_value = {'buying_power': '1000'}

        trades, new_positions = apply_rules(entry_rules, exit_rules, reverse_rules, stock_data, positions)

        assert trades == []
        assert new_positions == positions

    #  Tests that the function handles empty stock data lists. Tags: [edge case]
    def test_apply_rules_stock_data_empty(self, mocker):
        # Test that the function handles empty stock data lists
        entry_rules = [Rule(name='rule1', condition='condition1', actions=['action1'])]
        exit_rules = [Rule(name='rule2', condition='condition2', actions=['action2'])]
        reverse_rules = [Rule(name='rule3', condition='condition3', actions=['action3'])]
        stock_data = []
        positions = [Position(symbol='AAPL', qty=10, avg_price=100, side='long', time='2022-01-01')]

        api_mock = mocker.Mock()
        api_mock.get_account.return_value = {'buying_power': '1000'}

        trades, new_positions = apply_rules(entry_rules, exit_rules, reverse_rules, stock_data, positions)

        assert trades == []
        assert new_positions == positions

    #  Tests that the function handles empty positions lists. Tags: [edge case]
    def test_apply_rules_positions_empty(self, mocker):
        # Test that the function handles empty positions lists
        entry_rules = [Rule(name='rule1', condition='condition1', actions=['action1'])]
        exit_rules = [Rule(name='rule2', condition='condition2', actions=['action2'])]
        reverse_rules = [Rule(name='rule3', condition='condition3', actions=['action3'])]
        stock_data = [StockData(symbol='AAPL', date='2022-01-01', open=100, high=110, low=90, close=105, volume=1000, vwap=100, adj_close=100)]
        positions = []

        api_mock = mocker.Mock()
        api_mock.get_account.return_value = {'buying_power': '1000'}

        trades, new_positions = apply_rules(entry_rules, exit_rules, reverse_rules, stock_data, positions)

        assert trades == []
        assert new_positions == []

